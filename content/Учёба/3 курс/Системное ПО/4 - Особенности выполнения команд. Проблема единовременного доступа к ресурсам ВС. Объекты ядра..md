**Дата:** 04.03.2024
**Лектор:** (Лектор:: Ислямов Р.И.)
**Источник:** (Источник:: )
**Теги:** 

# Базовые понятия архитектуры операционных систем

***Базовые компоненты ОС***, которые отвечают за важнейшие ее функций, обычно находятся в памяти постоянно и выполняются в привилегированном режиме, они называются ядром операционной системы (operating system kernel).

Существующие на сегодня подходы к проектированию архитектуры ОС, по разному определяют функциональность ядра. К важнейшим функциям ОС, выполнение которых обычно возлагают на ядро, принадлежат обработке прерываний, управление памятью, управление вводом-выводом. К надежности и производительности ядра предъявляют повышенные требования.

Основным характерным признаком ядра является то, что оно выполняется в привилегированном режиме. Рассмотрим особенности этого режима.

Для обеспечения эффективного управления ресурсами компьютера, ОС должна иметь определенные привилегии по приложениям. Надо, чтобы приложения не вмешивались в работу ОС, и в то же время ОС должна иметь возможность вмешаться в работу любой программы, например для переключения процессора или разрешения конфликта в борьбе за ресурсы. Для реализации таких привилегий нужна аппаратная поддержка: процессор должен поддерживать по крайней мере два режима работы - ***привилегированный*** (защищенный режим, режим ядра, kernel mode) и ***режим пользователя*** (user mode). В режиме пользователя недопустимы команды, которые являются критическими для работы системы (переключение задач, обращения к памяти по заданным пределам, доступ к устройствам ввода-вывода и т.д.).

После загрузки ядро переключает процессор в привилегированный режим и получает полный контроль над компьютером. Каждое приложение запускается и выполняется в режиме, где оно не имеет доступа к ресурсам ядра и других программ. Когда нужно выполнить действие, реализованное в ядре, применение делает системный вызов (system call). Ядро перехватывает его, переключает процессор в привилегированный режим, выполняет действие, переключает процессор обратно в режим пользователя и возвращает результат применения.

Системный вызов выполняется медленнее вызова функции, реализованной в режиме пользователя, потому что процессор дважды переключается между режимами. Для повышения производительности в некоторых ОС часть функциональности реализована в режиме пользователя, поэтому для доступа к ней системные вызовы использовать не нужно.

# Способы управления памятью

Часть операционной системы, отвечающая за управление памятью, называется ***менеджером памяти***. В самой простой однозадачной системе в каждый конкретный момент времени работает только одна программа, при этом память разделяется между программой и операционной системой. Как только пользователь набирает команду, операционная система копирует запрашиваемую программу с диска в память и выполняет ее, а после окончания процесса выводит на экран приглашение и ждет новой команды. Получив инструкции, она загружает другую программу в память, записывая ее поверх предыдущей.

# Системное программное обеспечение

Кроме ядра, важными составляющими работы ОС также применение режима пользователя, которые выполняют системные функции. К такому системному программному обеспечению относятся:

* системные программы (утилиты), например: командный интерпретатор, программы резервного копирования и восстановления данных, средства диагностики и администрирования;
* системные библиотеки, в которых реализованы функций, используемые в подпрограммах пользователя.

Системное программное обеспечение может разрабатываться и поставляться отдельно от ОС. Например, может быть несколько реализаций командного интерпретатора, средств резервного копирования и тому подобное. Системные программы и библиотеки взаимодействуют с ядром таким же образом, как и приложения.

# Монолитные системы

ОС, в которых все базовые функции сконцентрированы в ядре, называют монолитными системами. В случае реализации монолитного ядра, ОС становится продуктивной (процессор не переключается между режимами при взаимодействии между ее омпонентами), но менее надежной (весь ее код выполняется в привилегированном режиме, и ошибка в каждом из компонентов является критической).

Монолитность ядра не означает, что все его компоненты должны постоянно находиться в памяти. Современные ОС позволяют динамично размещать в адресном пространстве ядра фрагменты кода (модули ядра). Реализация модулей ядра позволяет также достичь его расширяемости (для придания новой функциональности достаточно разработать и загрузить в память соответствующий модуль).

# Многоуровневые системы

Компоненты многоуровневых ОС образуют иерархию уровней (слоев, layers), каждый из которых опирается на функции предыдущего уровня. Самый низкий уровень непосредственно взаимодействует с аппаратным обеспечением, на самом высоком уровне реализуются системные вызовы.

В традиционных многоуровневых ОС передача управления с верхнего уровня на нижний реализуется как системный вызов. Верхний уровень должен иметь права на выполнение этого вызова, проверка этих прав выполняется при поддержке аппаратного обеспечения. Примером такой системы является ОС Multics, разработанная в 60-е годы. Практическое применение этого подхода сегодня ограничено из-за низкой производительности.

Уровни могут выделяться и в монолитном ядре; в таком случае они поддерживаются программно и вызывают упрощения реализации системы.

# Системы с микроядром

Одно из направлений развития современных ОС заключается в том, что в привилегированном режиме реализована небольшая часть функций ядра, которые являются микроядром (microkernel). Другие функции ОС выполняются процессами режима (серверными процессами, серверами). Серверы могут отвечать за поддержку файловой системы, за работу с процессами, памятью и тому подобное.

Микроядро осуществляет связь между компонентами системы и выполняет базовое распределение ресурсов. Чтобы выполнить системный вызов, процесс (клиентский процесс, клиент) обращается к минроядру. Микроядро посылает серверу запрос, сервер выполняет работу и пересылает ответ назад, а микроядро переправляет его клиенту. Клиентами могут быть не только процессы пользователя, но и другие модули ОС.

Преимуществами микроядерного подхода являются:
* небольшие размеры микроядра, что упрощает его разработку и отладку;
* высокая надежность системы, вследствие того что серверы работают в режиме пользователя и в них нет прямого доступа к оборудованию;
* большая гибкость и расширяемость системы (ненужные компоненты не занимают места в памяти, расширение функциональности системы сводится к добавлению в нее нового сервера);
* возможность адаптации к условиям сети (способ обмена данными между клиентом и сервером не зависит от того, связаны они сетью или находятся на одном компьютере).

Главным недостатком микроядерного подхода является снижение производительности. Вместо двух переключений режима процессора в случае системного вызова происходит четыре (два при обмене между клиентом и микроядром, два между сервером и микроядром).

Указанный недостаток является скорее теоретическим, на практике производительность и надежность микроядра зависят прежде всего от качества его реализации. Так, в ОС QNX микроядро занимает несколько килобайт памяти и обеспечивает минимальный набор функций, при этом система по производительности соответствует ОС реального времени.

# Архитектура Unix

Несмотря на многообразие версий UNIX, основой всего семейства являются принципиально одинаковая архитектура и ряд стандартных интерфейсов (в UNIX стандартизовано почти всё - от расположения системных папок и файлов, до интерфейса системных вызовов и списка драйверов базовых устройств). Опытный администратор без особого труда сможет обслуживать другую версию, тогда как для пользователей переход на другую систему и вовсе может оказаться незаметным. Для системных же программистов такого рода стандарты позволяют полностью сосредоточиться на программировании, не тратя время на изучение архитектуры и особенностей конкретной реализации системы.

В системе UNIX может одновременно выполняться множество процессов (задач), причем их число логически не ограничивается, и множество частей одной программы может одновременно находиться в системе. Благодаря специальному механизму управления памятью, каждый процесс развивается в своем защищенном адресном пространстве, что гарантирует безопасность и независимость от других процессов. Различные системные операции позволяют процессам порождать новые процессы, завершают процессы, синхронизируют выполнение этапов процесса и управляют реакцией на наступление различных событий.

Существует два основных объекта операционной системы UNIX, с которыми приходиться работать пользователю - файлы и процессы. Эти объекты сильно связаны друг с другом, и в целом организация работы с ними как раз и определяет архитектуру операционной системы.

Все данные пользователя хранятся в файлах; доступ к периферийным устройствам осуществляется посредством чтения и записи специальных файлов; во время выполнения программы, операционная система считывает исполняемый код из файла в память и передает ему управление.

С другой стороны, вся функциональность операционная определяется выполнением соответствующих процессов. В частности, обращение к файлам на диске невозможно, если файловая подсистема операционной системы (совокупность процессов, осуществляющих доступ к файлам) не имеет необходимого для этого кода в памяти.

# Структура ядра Unix

Ядро непосредственно взаимодействует с аппаратной частью компьютера, изолируя прикладные программы (процессы в пользовательской части операционной системы) от особенностей ее архитектуры. Ядро имеет набор услуг, предоставляемых прикладным программам посредством системных вызовов. Таким образом, в системе можно выделить два уровня привилегий: ***уровень системы*** (привилегии специального пользователя гoot) и ***уровень пользователя*** (привилегии всех остальных пользователей).

Важной частью системных программ являются ***демоны***. **Демон** - это процесс, выполняющий определенную функцию в системе, который запускается при старте системы и не связан ни с одним пользовательским терминалом. Демоны предоставляют пользователям определенные сервисы, примерами которых могут служить системный журнал, веб-сервер и т.п.. Аналогом демонов в операционной системе Windows NT и более поздних версиях являются системные службы.

![[image002.gif]]

Рисунок 5.1 Архитектура операционной системы UNIX.

Операционная система UNIX обладает классическим монолитным ядром, в котором можно выделить следующие основные части:

* Файловая подсистема
* Доступ к структурам ядра осуществляется через файловый интерфейс.
* Управление процессами

Сюда входит управление параллельным выполнением процессов (планирование и диспетчеризация), виртуальной памятью процесса, и взаимодействием между процессами (сигналы, очереди сообщений и т.п.).

# Файловая система Unix

Термин ***файловая система*** по историческим причинам обозначает одновременно и иерархию каталогов и файлов, и часть ядра, управляющую доступом к каталогам и файлам.

Каджый файл в древовидной структуре расположен в определенном хранилище файлов - каталоге, каждый каталог, в свою очередь, также расположен в некотором каталоге. Таким образом, по принципу
вложения элементов файловой системы (файлов и каталогов) друг в друга строится дерево, вершинами которого являются непустые каталоги, а листьями - файлы или пустые каталоги. Корень такого дерева имеет
название корневой каталог и обозначается каким-либо специальным символом или группой символов (например, «С:» в операционной системе Windows). Каждому файлу соответствует некоторое имя, определяющее его расположение в дереве файловой системы. Полное имя файла состоит из имен всех вершин дерева файловой системы, через которые можно пройти от корня до данного файла (каталога), записывая их слева на право и разделяя специальными символами разделителями.

Файлы и каталоги идентифицируются не по именам, а по индексным узлам (і- node) - индексам в общем массиве файлов для данной файловой системы. В этом массиве хранится информация об используемых блоках данных на носителе, а также - длина файла, владелец файла, права доступа и другая служебная информация под общим названием «метаданные о файле». Логические же связки типа «имя-i-node» - есть ни что иное как содержимое каталогов.

Таким образом, каждый файл характеризуется одним i-node, но может быть связан с несколькими именами в UNIX это называют жёсткими ссылками. При этом, удаление файла происходит тогда, когда удаляется последняя жёсткая ссылка на этот файл. Важной особенностью таких файловых систем является то, что имена файлов зависят от регистра, другими словами файлы test.txt и TEST.txt отличаются (т.е. являются разными строками в файле директории).

# Архитектура Linux

Являясь операционной системой семейства Unix, Linux следует установленным стандартам и объединяет в себе три основных части.

**Ядро** (kernel) - основной компонент ОС, отвечающий за управление процессами, виртуальной памятью и драйверами устройств. Ядро Linux представляет собой единый блок бинарного кода. Все коды ядра и структуры данных, в том числе драйверы устройств, коды распределения ресурсов и виртуальной памяти, сетевой поддержки, а так же файловая система - хранятся в едином адресном пространстве. Преимуществом такой структуры является то, что не требуется никаких переключений при запросах процессами системных ресурсов или прерываниях от различных устройств. Общее адресное пространство, не препятствует модульности системы. По мере необходимости Linux подгружает в память либо выгружает из нее указанные модули. В Linux ядро работает в привилегированном режиме - режиме ядра. Никакая часть кода не работает в режиме пользователя. Фрагменты поддержки ОС, не требующие запуска в режиме ядра, помещаются в раздел системных библиотек.

Разделяемые системные библиотеки (system libraries) содержат стандартный набор функций, используемых приложениями для запросов к системным сервисам ядра. В библиотеках хранятся также код функций отдельных сервисов ядра, исполняемых в обычном режиме без привилегий ядра. При обращении приложения к системным ресурсам управление от части системы, работающей в пользовательском режиме, передается ядру. Библиотеки осуществляют контроль за корректностью представленного запроса и преобразование параметров/аргументов запроса к требуемому формату.

Под ***системными утилитами*** (system utilities, программы управления системой) понимают программы, отвечающие за выполнение отдельных специализированных задач управления (управляющих функций системы). Одни учлиты запускаются лишь один раз для инициализации и конфигурирования отдельных элементов системы, другие вызываются регулярно, например, утилиты принимающие запросы на регистрацию с терминалов системы, либо утилиты обновляющие файлы регистрации. Не все утилиты выполняют функции системного администрирования. Часть системных программ отвечают за выполнение простых задач, в частности, просмотр каталогов, перенос и удаление файлов, просмотр содержимого файла. Более сложные поддерживают некоторые функции обработки текстовых данных, например, сортировку данных либо поиск по заданному шаблону в тексте.

# VFS Linux

VFS также предоставляет ядру возможность оперирования файловой системой, как с единым целым: операции монтирования и демонтирования, а также операции получения общих характеристик конкретной файловой системы (размера блока, количества свободных и занятых блоков и т.п.) в единой форме. Если конкретный тип файловой системы не поддерживает какую-то абстрактную операцию VFS, то файловая система должна вернуть ядру код возврата, извещающий об этом факте.

В состав VFS Linux входят два основных компонента: 
* Набор определений, характеризующих объект типа файл;
* Программный уровень, обеспечивающий работу с подобными объектами;

Основные типы объектов, выделяемых VFS:
* Индексы (inode, vnode) - представляют каждый элемент файловой системы 
* Файловые структуры (структура file) - представляют отдельные файлы
* Файловая система (file system) - представляет файловую систему в целом

Для каждого типа объектов VFS поддерживает свой набор разрешенных операций, ссылки на которые хранятся в таблице функций. По указателю конкретного объекта происходит обращение K требуемой области таблицы, хранящей фактические адреса функций, реализующих требуемые операции.

# Введение в процессы

Хотя на первый взгляд, кажется, что программа и процесс практически одинаковые, они фундаментально отличаются друг от друга. понятия Программа представляет собой статический набор команд, а процесс - это контейнер для набора ресурсов, используемых при выполнении экземпляра программы. На самом высоком уровне абстракции процесс в Windows включает следующее:
* закрытое виртуальное адресное пространство диапазон адресов виртуальной памяти, которым может пользоваться процесс;
* исполняемую программу - начальный код и данные, проецируемые на виртуальное адресное пространство процесса;
* список открытых описателей (handles) различных системных ресурсов семафоров, коммуникационных портов, файлов и других объектов, доступных всем потокам в данном процессе;
* контекст защиты (security context), называемый маркером доступа (access token) и идентифицирующий пользователя, группы безопасности и привилегии, сопоставленные с процессом;
* уникальный идентификатор процесса (во внутрисистемной терминологии называемый идентификатором клиента);
* минимум один поток.

Каждый процесс также указывает на свой родительский процесс (процесс-создатель). Однако, если родитель существует, эта информация не обновляется. Поэтому есть вероятность, что некий процесс указывает на уже несуществующего родителя. Это не создает никакой проблемы, поскольку никто не полагается на наличие такой информации.

Для просмотра (и модификации) процессов и информации, связанной с ними, существует целый набор утилит. Следующие эксперименты демонстрируют, как получить ту или иную информацию о процессе с помощью некоторых из этих утилит. Они включаются непосредственно:
* в саму Windows,
* B Windows Support Tools,
* Windows Debugging Tools,
* ресурсы Windows
* Platform SDK;

Многие из этих утилит выводят перекрывающиеся подмножества информации о базовых процессах и потоках, иногда идентифицируемые по разным именам.

# Потоки

***Поток*** (thread) некая сущность внутри процесса, получающая процессорное время для выполнения. Без потока программа процесса не может выполняться. Поток включает следующие наиболее важные элементы:
* содержимое набора регистров процессора, отражающих состояние процессора;
* два стека, один из которых используется **потоком** при выполнении в режиме ядра, а другой — в пользовательском режиме;
* закрытую область памяти, называемую локальной памятью потока (**thread-local storage, TLS**) и используемую подсистемами, библиотеками исполняющих систем (**run-time libraries**) и DLL;
* уникальный идентификатор потока (во внутрисистемной терминологии так же называемый идентификатором клиента: идентификаторы процессов и потоков генерируются из одного пространства имен и никогда не перекрываются);
* иногда потоки обладают своим контекстом защиты, который обычно используется многопоточными серверными приложениями, подменяющими контекст защиты обслуживаемых клиентов.

Переменные регистры, стеки и локальные области памяти называются контекстом потока. Поскольку эта информация различна на каждой аппаратной платформе, на которой может работать Windows, соответствующая структура данных специфична для конкретной платформы. Windows-функция
GetThread Context предоставляет доступ к этой аппаратно-зависимой информации (называемой блоком CONTEXT).

Хотя у потоков свой контекст выполнения, каждый поток внутри одного процесса делит его виртуальное адресное пространство (а также остальные ресурсы, принадлежащие процессу). Это означает, что все потоки в процессе могут записывать и считывать содержимое памяти любого из потоков данного процесса. Однако потоки не могут случайно сослаться на адресное пространство другого процесса. Исключение возможно в ситуации, когда тот предоставляет часть своего адресного пространства, как раздел общей памяти (shared memory section), B Windows API называемый объектом «проекция файла» (file mapping object), или когда один из процессов имеет право на открытие другого процесса и использует функции доступа к памяти между процессами, например ReadProcess Memory и WriteProcessMemory.

Кроме закрытого адресного пространства и одного или нескольких потоков у каждого процесса имеются идентификация защиты и список открытых описателей таких объектов, как файлы и разделы общей памяти, или синхронизирующих объектов вроде ***мьютексов, событий и семафоров***.

Каждый процесс обладает контекстом защиты, который хранится в объекте - **маркере доступа**. Маркер доступа содержит идентификацию защиты и определяет полномочия данного процесса. По умолчанию у потока нет собственного маркера доступа, но он может получить его, и это позволит ему подменять контекст защиты другого процесса (в том числе выполняемого на удаленной системе Windows). ***Дескрипторы виртуальных адресов*** (virtual address descriptors, VAD) - это структуры данных, используемые диспетчером памяти для учета виртуальных адресов, задействованных процессом.

# Задания операционной системы

Windows предоставляет расширение для модели процессов (jobs). Они предназначены в основном для того, чтобы группами процессов - задания можно было оперировать и управлять как единым целым. Объект-задание позволяет устанавливать определенные атрибуты и накладывать ограничения на процессили процессы, сопоставленные с заданием. В этом объекте также хранится информация обо всех процессах, которые были сопоставлены с заданием, но к настоящему времени уже завершены. В каких-то отношениях объект-задание компенсирует отсутствие иерархического дерева процессов в Windows, а в каких-то - даже превосходит по своим возможностям дерево процессов UNIX.

# Понятие процессов в UNIX

В UNIX (и большинстве современных операционных систем, таких как Microsoft Windows, Mac OS X, FreeBSD и Linux) каждая задача представляется как процесс UNIX способен выполнять много задач одновременно, потому что процессы поочередно выполняются на центральном процессоре в течение очень непродолжительного промежутка времени.

***Процесс*** - это нечто вроде контейнера, объединяющего выполняемое приложение, его переменные среды, состояние потоков ввода/вывода приложения и параметры процесса, включающие в себя его приоритет и степень использования ресурсов системы.

Каждый процесс имеет своего владельца. Задачи, инициализируемые пользователем, например, его shell и командами, обычно принадлежат этому пользователю. Системные процессы могут принадлежать пользователям с особыми правами или системному администратору root. Например, для повышения безопасности Apache HTTP Server обычно принадлежит выделенному пользователю с именем www, который предоставляет Web- серверу только доступ к файлам, которые ему необходимы для работы.

# Процессы в Linux

Процесс в Linux (как и в UNIX) - это программа, которая выполняется в отдельном виртуальном адресном пространстве. Когда пользователь регистрируется в системе, автоматически создается процесс, в котором выполняется оболочка (shell), например, /bin/bash.

В Linux поддерживается классическая схема мультипрограммирования. Linux поддерживает параллельное (или квазипараллельного при наличии только одного процессора) выполнение процессов пользователя. Каждый процесс выполняется в собственном виртуальном адресном пространстве, т.е. процессы защищены друг от друга и крах одного процесса никак не повлияет на другие выполняющиеся процессы и на всю систему в целом. Один процесс не может прочитать что-либо из памяти (или записать в нее) другого процесса без "разрешения" на то другого процесса. Санкционированные взаимодействия между процессами допускаются системой.

# Создание новых процессов в Unix

В UNIX некоторые процессы выполняются с момента загрузки компьютера до его выключения, но большинство процессов имеет короткий жизненный цикл, ограничивающийся началом и окончанием выполнения задачи. Иногда процесс может быть принудительно завершен. Каждый новый процесс в UNIX является перевоплощением существующего процесса. Или, по другому, каждый новый процесс- давайте называть его дочерним - является клоном своего процесса- родителя хотя бы на мгновенье, пока дочерний процесс не начнет выполняться самостоятельно.

# Управление процессами Unix

Некоторые процессы работают с момента включения компьютера до его выключения (init, к примеру), а некоторые процессы перевоплощают себя в новую форму (оболочка, к примеру). Но большинство процессов заканчивают свое выполнение, как только выполнят соответствующую им задачу.

Кроме того, можно временно приостановить деятельность процесса или принудительно завершить процесс командой kill.

# Работа с процессами в Linux

Ядро предоставляет системные вызовы для создания новых процессов и для управления порожденными процессами. Любая программа может начать выполняться только если другой процессее запустит или произойдет какое-то прерывание (например, прерывание внешнего устройства).

В связи с развитием SMP (Symmetric Multiprocessor Architectures) в ядро Linux был внедрен механизм нитей или потоков управления (threads). ***Нить*** - это процесс, который выполняется в виртуальной памяти, используемой вместе с другими нитями процесса, который обладает отдельной виртуальной памятью.

Если интерпретатору (shell) встречается команда, соответствующая выполняемому файлу, интерпретатор выполняет ее, начиная с точки входа (entry point). Для С-программ entry point - это функция main. Запущенная программа тоже может создать процесс, т.е. запустить какую-то программу и ее выполнение тоже начнется с функции main.

Для создания процессов используются два системных вызова: fork() и ехес. fork() создает новое адресное пространство, которое полностью идентично адресному пространству основного процесса. После выполнения этого системного вызова мы получаем два абсолютно одинаковых процесса - основной и порожденный. Функция fork() возвращает о в порожденном процессе и PID (Process ID - идентификатор порожденного процесса) - в основном. PID - это целое число.

Теперь, когда мы уже создали процесс, мы можем запустить программу с помощью вызова ехес. Параметрами функции ехес является имя выполняемого файла и, если нужно, параметры, которые будут переданы этой программе. В адресное пространство порожденного с помощью fork() процесса будет загружена новая программа и ее выполнение начнется с точки входа (адрес функции мain).

Управление устройствами ввода-вывода